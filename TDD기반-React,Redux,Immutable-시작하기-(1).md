> http://www.theodo.fr/blog/2016/03/getting-started-with-react-redux-and-immutable-a-test-driven-tutorial-part-1/ 를 번역한 글입니다.


몇 주 전에, 저는 할일 없이 [해커 뉴스](https://news.ycombinator.com/)를 보고, Redux에 관한 헤드라인을 봤습니다. 헤드라인을 읽고 Redux는 React와 잘 어울리는 다른 요소라고 이해를 했었습니다. 하지만 자바스크립트에 대해 이미 [피로도](https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.bk12bq4lc)가 쌓여있었기 때문에, 저는 Redux의 다음 특징에 대해 읽기 전까진 거의 신경 쓰지 않고 있었습니다. :

- 함수형 프로그래밍을 수행하고, 어플리케이션의 동작을 예상하고 보장합니다.
- 서버와 클라이언트 간의 코드를 공유하는 동형(*isomorphic*) 어플리케이션을 허락합니다.
- [시간 여행 디버깅](https://code-cartoons.com/hot-reloading-and-time-travel-debugging-what-are-they-3c8ed2812f35#.l69um5b92)(역자주: 시간여행 디버깅은 버그 가 나기 이전 상태로 돌아가서 테스팅을 할 수 있게 해주는 방식)이 가능한가요?

Redux는 마치 React 어플리케이션의 상태를 관리하는 우아한 솔루션인 것 처럼 보였습니다. 누가 시간 여행 디버깅을 반대하겠습니까?
그래저 저는 공식 문서와 [@teropa](https://twitter.com/teropa)의 [환상적인 튜토리얼](http://teropa.info/blog/2015/09/10/full-stack-redux-tutorial.html)을 읽었습니다.( 이 포스팅의 중요한 영감을 얻은 곳입니다.)  
코드는 우아하고, 디버거는 매우 훌륭합니다. 제말은 다음을 봐보세요.

![todo 영상](http://www.theodo.fr/uploads/blog//2016/02/time-travel.gif)

이번 첫번째 파트에서 만들 앱은 Redux가 일하는 방식에 대한 기본적인 원칙에 대한 것입니다. 다소 간결하게 하기 위해 일부러 범위를 제한적으로 두었습니다.(클라이언트측에만 존재라 동형 앱이 아닌 단순한 앱) 만약 당신이 더 깊게 알고 싶다면, 위에 환상적인 튜토리얼을 권합니다. Gihub 저장소는 [여기](https://github.com/phacks/redux-todomvc) 에 있으며, 최종 앱의 모습을 담고 있습니다. 코드나 튜토리얼에 대한 질문이나 제안은 코멘트를 남기거나 Pull Request를 하십시오.  

#앱
이번 튜토리얼의 목적을 위해 우리는 전통적인 `TodoMVC`앱을 만들 것입니다. 이를 위해 다음과 같은 요구사항이 있습니다.

- 각 할일은 활성화 또는 완료 할 수 있습니다.
- 할일은 추가,수정,삭제가 가능합니다.
- 할일들은 상태에 따라 필터링 할 수 있습니다.
- 활성화된 할일 카운팅은 하단에 배치합니다.
- 완료된 할일들은 한꺼번에 삭제가 가능합니다.

당신은 [여기](http://todomvc.com/examples/react/#/) <- 서 앱의 예를 보실 수 있습니다.

#Redux와 Immutable: 함수형 프로그래밍
몇달전, 저는 대쉬보드 웹앱을 개발하고 있었습니다. 웹앱이 커져감에 따라, 점점 더 찾기 힘든 많은 버그들을 발견하게 되었습니다. "이 페이지로 이동해서 버튼을 클릭하고, 다시 메인 페이지로 돌아가서 커피를 잡고, 아까 그 페이지로 이동하고 다시 클릭하면 무언가 기묘한 일이 발생" 과 같은 버그였습니다. 이 모든 버그의 근원은 우리 모든 코드와 로직에 영향을 미쳤습니다. 이 행동은 우리가 알지 못했던 다른 곳에 원치 핞는 영향을 미칠 수 있었습니다.  
  
앱의 모든 상태를 가지고 있는 단일 자료구조인 상태트리야 말로 Redux의 힘입니다. 이 의미는 매순간마다, 사용자에게 보여지는 데이터는 상태 트리 안에 있는 결과이며, 단일 출처를 제공하는 것입니다. 우리 앱의 모든 액션은 상태트리에서 가져와서 해당 수정사항을 반영하고(예를들어 할일을 추가 하는것), 업데이트된 상태 트리를 사용자에게 렌더링 합니다. 애매한 부작용은 없으며, 실수로 수정한 변수 참조는 더이상 없습니다. 이는 관심사의 명확한 분리와 좋은 앱 구조를 만들고, 더 나은 디버깅을 할 수 있게 됩니다.

